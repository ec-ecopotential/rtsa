% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rtsa_gapfill.R
\name{rtsa.gapfill}
\alias{rtsa.gapfill}
\title{Raster time series gap-filling}
\usage{
rtsa.gapfill(x, rastermask = NULL, method, cores = 1L, verbose = FALSE)
}
\arguments{
\item{x}{Input raster time series as \code{\linkS4class{RasterStackTS}} or \code{\linkS4class{RasterBrickTS}} object}

\item{rastermask}{A \code{\linkS4class{RasterLayer}} to use as a mask. If not set
a raster mask is computed to remove all pixels with less than two values in temporal profiles}

\item{method}{Character. Defines the algorithm to be used to interpolate pixels with incomplete temporal profiles. 
Accepts the following input:
\tabular{lll}{
\tab \code{"linear"} \tab for linear interpolation in \code{\link[imputeTS]{na.interpolation}} using \code{\link[stats]{approxfun}}\cr
\tab \code{"spline"} \tab for spline interpolation in \code{\link[imputeTS]{na.interpolation}} using \code{\link[stats]{splinefun}}\cr
\tab \code{"stine"} \tab for stine interpolation in \code{\link[imputeTS]{na.interpolation}} using \code{\link[stinepack]{stinterp}}\cr
\tab \code{"dineof"} \tab for dineof interpolation using \code{\link[sinkr]{dineof}}\cr
}}

\item{cores}{Integer. Defines the number of CPU to be used for multicore processing. Default to "1" core for 
singlecore processing.}

\item{...}{Additional arguments}
}
\value{
Object of class \code{\linkS4class{RasterBrickTS}} with gap-filled pixels
}
\description{
This function perform gap-filling of gappy raster time series
}
\details{

}
\examples{
\dontrun{
## create raster time series using the 'pacificSST' data from 'remote' package
require(remote)

data(pacificSST)
pacificSST[which(getValues(pacificSST == 0))] <- NA # set NA values
# create rts object
rasterts <- rts(pacificSST, seq(as.Date('1982-01-15'), as.Date('2010-12-15'), 'months'))

## generate raster mask
raster_mask <- pacificSST[[1]] # create raster mask
values(raster_mask) <- 1 # set raster mask values
raster_mask[which(is.na(getValues(pacificSST[[1]])))] <- 0 # set raster mask values

## randomly remove values from cells in rts object
frac_gaps <- 0.5 # the fraction of data with NaNs
temporal_cells <- as.integer(ncell(rasterts) * nlayers(rasterts)) # number of total cells in rts
# define random position of cells to be set to NaN
na_cells <- sort(unique(sample.int(temporal_cells, (temporal_cells * frac_gaps))))
gappy_values <- as.vector(getValues(rasterts)) # extract raster values
gappy_values[na_cells] <- NA # set NA to random positions
rasterts_gappy <- setValues(rasterts, values=gappy_values) # set NA to pixels

## perform gap-filling on the gappy dataset

# using linear interpolation
rasterts_linear <- rtsa.gapfill(rasterts_gappy, method="linear")

# using spline interpolation and multiple cores
rasterts_spline <- rtsa.gapfill(rasterts_gappy, method="spline", cores=4)

# using stine interpolation and raster mask
rasterts_stine <- rtsa.gapfill(rasterts_gappy, rastermask=raster_mask, method="stine")

# using dineof interpolation and raster mask
rasterts_dineof <- rtsa.gapfill(rasterts_gappy, rastermask=raster_mask, method="dineof")
}

}
\references{

}
\seealso{
\code{\link[imputeTS]{na.interpolation}}, \code{\link[sinkr]{dineof}}, \code{\link[stats]{approxfun}}, \code{\link[stats]{splinefun}}, \code{\link[stinepack]{stinterp}}
}
\author{
Federico Filipponi
}
\keyword{analysis}
\keyword{gap-filling}
\keyword{series}
\keyword{time}
